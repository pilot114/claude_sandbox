<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>01. Phong Lighting - WebGPU</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
            font-family: monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            border: 2px solid #16213e;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        .info {
            margin: 20px;
            padding: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            max-width: 800px;
        }
        h1 { color: #ffd700; }
        a { color: #4da6ff; }
    </style>
</head>
<body>
    <h1>01. Phong Lighting Model</h1>
    <canvas id="canvas" width="800" height="600"></canvas>
    <div class="info">
        <h3>Concept:</h3>
        <p>Phong lighting combines three components:</p>
        <ul>
            <li><strong>Ambient:</strong> Base light level (simulates indirect lighting)</li>
            <li><strong>Diffuse:</strong> Light scattered equally in all directions (matte surfaces)</li>
            <li><strong>Specular:</strong> Reflected light in a preferred direction (shiny surfaces)</li>
        </ul>
        <p>The cube rotates automatically. Notice how the lighting changes based on surface angle.</p>
        <a href="index.html">‚Üê Back to examples</a>
    </div>

    <script type="module">
        const canvas = document.getElementById('canvas');
        const adapter = await navigator.gpu?.requestAdapter();
        const device = await adapter?.requestDevice();

        if (!device) {
            alert('WebGPU not supported!');
            throw new Error('WebGPU not supported');
        }

        const context = canvas.getContext('webgpu');
        const format = navigator.gpu.getPreferredCanvasFormat();
        context.configure({ device, format });

        // Cube vertices with positions and normals
        const vertices = new Float32Array([
            // Front face
            -1, -1,  1,  0,  0,  1,
             1, -1,  1,  0,  0,  1,
             1,  1,  1,  0,  0,  1,
            -1,  1,  1,  0,  0,  1,
            // Back face
            -1, -1, -1,  0,  0, -1,
            -1,  1, -1,  0,  0, -1,
             1,  1, -1,  0,  0, -1,
             1, -1, -1,  0,  0, -1,
            // Top face
            -1,  1, -1,  0,  1,  0,
            -1,  1,  1,  0,  1,  0,
             1,  1,  1,  0,  1,  0,
             1,  1, -1,  0,  1,  0,
            // Bottom face
            -1, -1, -1,  0, -1,  0,
             1, -1, -1,  0, -1,  0,
             1, -1,  1,  0, -1,  0,
            -1, -1,  1,  0, -1,  0,
            // Right face
             1, -1, -1,  1,  0,  0,
             1,  1, -1,  1,  0,  0,
             1,  1,  1,  1,  0,  0,
             1, -1,  1,  1,  0,  0,
            // Left face
            -1, -1, -1, -1,  0,  0,
            -1, -1,  1, -1,  0,  0,
            -1,  1,  1, -1,  0,  0,
            -1,  1, -1, -1,  0,  0,
        ]);

        const indices = new Uint16Array([
            0,  1,  2,    0,  2,  3,    // front
            4,  5,  6,    4,  6,  7,    // back
            8,  9, 10,    8, 10, 11,    // top
           12, 13, 14,   12, 14, 15,    // bottom
           16, 17, 18,   16, 18, 19,    // right
           20, 21, 22,   20, 22, 23,    // left
        ]);

        const vertexBuffer = device.createBuffer({
            size: vertices.byteLength,
            usage: GPUBufferUsage.VERTEX,
            mappedAtCreation: true,
        });
        new Float32Array(vertexBuffer.getMappedRange()).set(vertices);
        vertexBuffer.unmap();

        const indexBuffer = device.createBuffer({
            size: indices.byteLength,
            usage: GPUBufferUsage.INDEX,
            mappedAtCreation: true,
        });
        new Uint16Array(indexBuffer.getMappedRange()).set(indices);
        indexBuffer.unmap();

        // Uniform buffer for matrices and lighting
        const uniformBufferSize =
            16 * 4 + // model matrix
            16 * 4 + // view matrix
            16 * 4 + // projection matrix
            16 * 4 + // normal matrix
            4 * 4 +  // lightPosition
            4 * 4 +  // viewPosition
            4 * 4;   // material properties (ambient, diffuse, specular, shininess)

        const uniformBuffer = device.createBuffer({
            size: uniformBufferSize,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        const bindGroupLayout = device.createBindGroupLayout({
            entries: [{
                binding: 0,
                visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
                buffer: { type: 'uniform' }
            }]
        });

        const bindGroup = device.createBindGroup({
            layout: bindGroupLayout,
            entries: [{
                binding: 0,
                resource: { buffer: uniformBuffer }
            }]
        });

        const shaderCode = `
            struct Uniforms {
                model: mat4x4<f32>,
                view: mat4x4<f32>,
                projection: mat4x4<f32>,
                normalMatrix: mat4x4<f32>,
                lightPosition: vec4<f32>,
                viewPosition: vec4<f32>,
                material: vec4<f32>, // ambient, diffuse, specular, shininess
            }

            @group(0) @binding(0) var<uniform> uniforms: Uniforms;

            struct VertexInput {
                @location(0) position: vec3<f32>,
                @location(1) normal: vec3<f32>,
            }

            struct VertexOutput {
                @builtin(position) position: vec4<f32>,
                @location(0) fragPosition: vec3<f32>,
                @location(1) normal: vec3<f32>,
            }

            @vertex
            fn vertexMain(input: VertexInput) -> VertexOutput {
                var output: VertexOutput;
                let worldPosition = uniforms.model * vec4<f32>(input.position, 1.0);
                output.fragPosition = worldPosition.xyz;
                output.position = uniforms.projection * uniforms.view * worldPosition;
                output.normal = (uniforms.normalMatrix * vec4<f32>(input.normal, 0.0)).xyz;
                return output;
            }

            @fragment
            fn fragmentMain(input: VertexOutput) -> @location(0) vec4<f32> {
                let normal = normalize(input.normal);
                let lightDir = normalize(uniforms.lightPosition.xyz - input.fragPosition);
                let viewDir = normalize(uniforms.viewPosition.xyz - input.fragPosition);
                let reflectDir = reflect(-lightDir, normal);

                // Ambient
                let ambient = uniforms.material.x * vec3<f32>(0.3, 0.5, 0.8);

                // Diffuse
                let diff = max(dot(normal, lightDir), 0.0);
                let diffuse = uniforms.material.y * diff * vec3<f32>(0.3, 0.5, 0.8);

                // Specular
                let spec = pow(max(dot(viewDir, reflectDir), 0.0), uniforms.material.w);
                let specular = uniforms.material.z * spec * vec3<f32>(1.0, 1.0, 1.0);

                let result = ambient + diffuse + specular;
                return vec4<f32>(result, 1.0);
            }
        `;

        const shaderModule = device.createShaderModule({ code: shaderCode });

        const pipeline = device.createRenderPipeline({
            layout: device.createPipelineLayout({
                bindGroupLayouts: [bindGroupLayout]
            }),
            vertex: {
                module: shaderModule,
                entryPoint: 'vertexMain',
                buffers: [{
                    arrayStride: 6 * 4,
                    attributes: [
                        { shaderLocation: 0, offset: 0, format: 'float32x3' },
                        { shaderLocation: 1, offset: 3 * 4, format: 'float32x3' },
                    ]
                }]
            },
            fragment: {
                module: shaderModule,
                entryPoint: 'fragmentMain',
                targets: [{ format }]
            },
            primitive: {
                topology: 'triangle-list',
                cullMode: 'back',
            },
            depthStencil: {
                depthWriteEnabled: true,
                depthCompare: 'less',
                format: 'depth24plus',
            },
        });

        const depthTexture = device.createTexture({
            size: [canvas.width, canvas.height],
            format: 'depth24plus',
            usage: GPUTextureUsage.RENDER_ATTACHMENT,
        });

        // Matrix math utilities
        function perspective(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) * nf, -1,
                0, 0, 2 * far * near * nf, 0
            ]);
        }

        function lookAt(eye, center, up) {
            const z = normalize([eye[0] - center[0], eye[1] - center[1], eye[2] - center[2]]);
            const x = normalize(cross(up, z));
            const y = cross(z, x);
            return new Float32Array([
                x[0], y[0], z[0], 0,
                x[1], y[1], z[1], 0,
                x[2], y[2], z[2], 0,
                -dot(x, eye), -dot(y, eye), -dot(z, eye), 1
            ]);
        }

        function rotateY(angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            return new Float32Array([
                c, 0, s, 0,
                0, 1, 0, 0,
                -s, 0, c, 0,
                0, 0, 0, 1
            ]);
        }

        function normalize(v) {
            const len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
            return [v[0]/len, v[1]/len, v[2]/len];
        }

        function cross(a, b) {
            return [
                a[1] * b[2] - a[2] * b[1],
                a[2] * b[0] - a[0] * b[2],
                a[0] * b[1] - a[1] * b[0]
            ];
        }

        function dot(a, b) {
            return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
        }

        function transpose3x3(m) {
            return new Float32Array([
                m[0], m[4], m[8], 0,
                m[1], m[5], m[9], 0,
                m[2], m[6], m[10], 0,
                0, 0, 0, 1
            ]);
        }

        let rotation = 0;
        function render() {
            rotation += 0.01;

            const uniformData = new Float32Array(uniformBufferSize / 4);
            const modelMatrix = rotateY(rotation);
            const viewMatrix = lookAt([0, 2, 5], [0, 0, 0], [0, 1, 0]);
            const projectionMatrix = perspective(Math.PI / 4, canvas.width / canvas.height, 0.1, 100);
            const normalMatrix = transpose3x3(modelMatrix);

            uniformData.set(modelMatrix, 0);
            uniformData.set(viewMatrix, 16);
            uniformData.set(projectionMatrix, 32);
            uniformData.set(normalMatrix, 48);
            uniformData.set([2, 3, 4, 1], 64); // light position
            uniformData.set([0, 2, 5, 1], 68); // view position
            uniformData.set([0.3, 0.7, 1.0, 32], 72); // material: ambient, diffuse, specular, shininess

            device.queue.writeBuffer(uniformBuffer, 0, uniformData);

            const commandEncoder = device.createCommandEncoder();
            const renderPass = commandEncoder.beginRenderPass({
                colorAttachments: [{
                    view: context.getCurrentTexture().createView(),
                    clearValue: { r: 0.1, g: 0.1, b: 0.15, a: 1 },
                    loadOp: 'clear',
                    storeOp: 'store',
                }],
                depthStencilAttachment: {
                    view: depthTexture.createView(),
                    depthClearValue: 1.0,
                    depthLoadOp: 'clear',
                    depthStoreOp: 'store',
                }
            });

            renderPass.setPipeline(pipeline);
            renderPass.setBindGroup(0, bindGroup);
            renderPass.setVertexBuffer(0, vertexBuffer);
            renderPass.setIndexBuffer(indexBuffer, 'uint16');
            renderPass.drawIndexed(indices.length);
            renderPass.end();

            device.queue.submit([commandEncoder.finish()]);
            requestAnimationFrame(render);
        }

        render();
    </script>
</body>
</html>
