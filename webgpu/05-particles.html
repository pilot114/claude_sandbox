<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>05. Particle System - WebGPU</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
            font-family: monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            border: 2px solid #16213e;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        .info {
            margin: 20px;
            padding: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            max-width: 800px;
        }
        h1 { color: #ffd700; }
        a { color: #4da6ff; }
    </style>
</head>
<body>
    <h1>05. GPU Particle System</h1>
    <canvas id="canvas" width="800" height="600"></canvas>
    <div class="info">
        <h3>Concept:</h3>
        <p>GPU-accelerated particle simulation using compute shaders:</p>
        <ul>
            <li><strong>Compute Shader:</strong> Updates particle physics on GPU (position, velocity, lifetime)</li>
            <li><strong>Storage Buffers:</strong> Read/write buffers shared between compute and render pipelines</li>
            <li><strong>Massively Parallel:</strong> 10,000+ particles updated simultaneously</li>
        </ul>
        <p>Watch the fountain of particles! Each particle has physics (gravity, velocity) computed entirely on GPU.</p>
        <a href="index.html">‚Üê Back to examples</a>
    </div>

    <script type="module">
        const canvas = document.getElementById('canvas');
        const adapter = await navigator.gpu?.requestAdapter();
        const device = await adapter?.requestDevice();

        if (!device) {
            alert('WebGPU not supported!');
            throw new Error('WebGPU not supported');
        }

        const context = canvas.getContext('webgpu');
        const format = navigator.gpu.getPreferredCanvasFormat();
        context.configure({ device, format });

        const NUM_PARTICLES = 10000;

        // Initialize particle data
        const initialParticleData = new Float32Array(NUM_PARTICLES * 8);
        for (let i = 0; i < NUM_PARTICLES; i++) {
            const offset = i * 8;
            // Position (xyz)
            initialParticleData[offset + 0] = 0;
            initialParticleData[offset + 1] = 0;
            initialParticleData[offset + 2] = 0;
            // Velocity (xyz)
            const angle = Math.random() * Math.PI * 2;
            const speed = 2 + Math.random() * 2;
            initialParticleData[offset + 3] = Math.cos(angle) * speed;
            initialParticleData[offset + 4] = 4 + Math.random() * 3;
            initialParticleData[offset + 5] = Math.sin(angle) * speed;
            // Life (current, max)
            initialParticleData[offset + 6] = Math.random() * 3;
            initialParticleData[offset + 7] = 3 + Math.random() * 2;
        }

        // Particle buffers (double buffering for compute)
        const particleBuffers = [0, 1].map(() => {
            const buffer = device.createBuffer({
                size: initialParticleData.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            });
            device.queue.writeBuffer(buffer, 0, initialParticleData);
            return buffer;
        });

        // Uniforms for simulation
        const simUniformBuffer = device.createBuffer({
            size: 4 * 4, // deltaTime, time, and padding
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        // Uniforms for rendering
        const renderUniformBuffer = device.createBuffer({
            size: 16 * 4 * 2, // view and projection matrices
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        // Compute shader for particle simulation
        const computeShader = `
            struct Particle {
                position: vec3<f32>,
                velocity: vec3<f32>,
                life: f32,
                maxLife: f32,
            }

            struct SimParams {
                deltaTime: f32,
                time: f32,
            }

            @group(0) @binding(0) var<storage, read> particlesIn: array<Particle>;
            @group(0) @binding(1) var<storage, read_write> particlesOut: array<Particle>;
            @group(0) @binding(2) var<uniform> params: SimParams;

            @compute @workgroup_size(64)
            fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
                let index = global_id.x;
                if (index >= arrayLength(&particlesIn)) {
                    return;
                }

                var particle = particlesIn[index];

                // Update lifetime
                particle.life += params.deltaTime;

                // Reset particle if dead
                if (particle.life >= particle.maxLife) {
                    particle.life = 0.0;
                    particle.position = vec3<f32>(0.0, 0.0, 0.0);

                    // Random direction with some variation
                    let seed = f32(index) + params.time;
                    let angle = (sin(seed * 12.9898) * 43758.5453) * 6.28318;
                    let speed = 2.0 + (sin(seed * 78.233) * 43758.5453 % 1.0) * 2.0;

                    particle.velocity.x = cos(angle) * speed;
                    particle.velocity.y = 4.0 + (sin(seed * 45.164) * 43758.5453 % 1.0) * 3.0;
                    particle.velocity.z = sin(angle) * speed;
                } else {
                    // Apply gravity
                    particle.velocity.y -= 9.8 * params.deltaTime;

                    // Update position
                    particle.position += particle.velocity * params.deltaTime;
                }

                particlesOut[index] = particle;
            }
        `;

        // Render shaders
        const renderShader = `
            struct Particle {
                position: vec3<f32>,
                velocity: vec3<f32>,
                life: f32,
                maxLife: f32,
            }

            struct Uniforms {
                view: mat4x4<f32>,
                projection: mat4x4<f32>,
            }

            @group(0) @binding(0) var<uniform> uniforms: Uniforms;

            struct VertexOutput {
                @builtin(position) position: vec4<f32>,
                @location(0) color: vec4<f32>,
            }

            @vertex
            fn vertexMain(@location(0) position: vec3<f32>, @location(3) life: f32, @location(4) maxLife: f32) -> VertexOutput {
                var output: VertexOutput;
                output.position = uniforms.projection * uniforms.view * vec4<f32>(position, 1.0);

                // Color based on lifetime
                let t = life / maxLife;
                let r = 1.0 - t * 0.5;
                let g = 0.5 + t * 0.5;
                let b = 0.3;
                let a = 1.0 - t; // Fade out

                output.color = vec4<f32>(r, g, b, a);
                return output;
            }

            @fragment
            fn fragmentMain(input: VertexOutput) -> @location(0) vec4<f32> {
                return input.color;
            }
        `;

        const computeModule = device.createShaderModule({ code: computeShader });
        const renderModule = device.createShaderModule({ code: renderShader });

        // Compute pipeline
        const computeBindGroupLayout = device.createBindGroupLayout({
            entries: [
                { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
                { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
                { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },
            ]
        });

        const computePipeline = device.createComputePipeline({
            layout: device.createPipelineLayout({
                bindGroupLayouts: [computeBindGroupLayout]
            }),
            compute: {
                module: computeModule,
                entryPoint: 'main',
            }
        });

        const computeBindGroups = [
            device.createBindGroup({
                layout: computeBindGroupLayout,
                entries: [
                    { binding: 0, resource: { buffer: particleBuffers[0] } },
                    { binding: 1, resource: { buffer: particleBuffers[1] } },
                    { binding: 2, resource: { buffer: simUniformBuffer } },
                ]
            }),
            device.createBindGroup({
                layout: computeBindGroupLayout,
                entries: [
                    { binding: 0, resource: { buffer: particleBuffers[1] } },
                    { binding: 1, resource: { buffer: particleBuffers[0] } },
                    { binding: 2, resource: { buffer: simUniformBuffer } },
                ]
            }),
        ];

        // Render pipeline
        const renderBindGroupLayout = device.createBindGroupLayout({
            entries: [
                { binding: 0, visibility: GPUShaderStage.VERTEX, buffer: { type: 'uniform' } },
            ]
        });

        const renderPipeline = device.createRenderPipeline({
            layout: device.createPipelineLayout({
                bindGroupLayouts: [renderBindGroupLayout]
            }),
            vertex: {
                module: renderModule,
                entryPoint: 'vertexMain',
                buffers: [{
                    arrayStride: 8 * 4,
                    attributes: [
                        { shaderLocation: 0, offset: 0, format: 'float32x3' }, // position
                        { shaderLocation: 3, offset: 6 * 4, format: 'float32' }, // life
                        { shaderLocation: 4, offset: 7 * 4, format: 'float32' }, // maxLife
                    ]
                }]
            },
            fragment: {
                module: renderModule,
                entryPoint: 'fragmentMain',
                targets: [{
                    format,
                    blend: {
                        color: {
                            srcFactor: 'src-alpha',
                            dstFactor: 'one',
                            operation: 'add',
                        },
                        alpha: {
                            srcFactor: 'zero',
                            dstFactor: 'one',
                            operation: 'add',
                        }
                    }
                }]
            },
            primitive: {
                topology: 'point-list',
            },
            depthStencil: {
                depthWriteEnabled: true,
                depthCompare: 'less',
                format: 'depth24plus',
            },
        });

        const renderBindGroup = device.createBindGroup({
            layout: renderBindGroupLayout,
            entries: [
                { binding: 0, resource: { buffer: renderUniformBuffer } },
            ]
        });

        const depthTexture = device.createTexture({
            size: [canvas.width, canvas.height],
            format: 'depth24plus',
            usage: GPUTextureUsage.RENDER_ATTACHMENT,
        });

        // Matrix utilities
        function perspective(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) * nf, -1,
                0, 0, 2 * far * near * nf, 0
            ]);
        }

        function lookAt(eye, center, up) {
            const z = normalize([eye[0] - center[0], eye[1] - center[1], eye[2] - center[2]]);
            const x = normalize(cross(up, z));
            const y = cross(z, x);
            return new Float32Array([
                x[0], y[0], z[0], 0,
                x[1], y[1], z[1], 0,
                x[2], y[2], z[2], 0,
                -dot(x, eye), -dot(y, eye), -dot(z, eye), 1
            ]);
        }

        function normalize(v) {
            const len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
            return [v[0]/len, v[1]/len, v[2]/len];
        }

        function cross(a, b) {
            return [
                a[1] * b[2] - a[2] * b[1],
                a[2] * b[0] - a[0] * b[2],
                a[0] * b[1] - a[1] * b[0]
            ];
        }

        function dot(a, b) {
            return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
        }

        let time = 0;
        let lastTime = performance.now();
        let bufferIndex = 0;

        function render() {
            const now = performance.now();
            const deltaTime = Math.min((now - lastTime) / 1000, 0.1);
            lastTime = now;
            time += deltaTime;

            // Update simulation uniforms
            const simParams = new Float32Array([deltaTime, time, 0, 0]);
            device.queue.writeBuffer(simUniformBuffer, 0, simParams);

            // Update render uniforms
            const angle = time * 0.3;
            const view = lookAt(
                [Math.cos(angle) * 15, 8, Math.sin(angle) * 15],
                [0, 2, 0],
                [0, 1, 0]
            );
            const projection = perspective(Math.PI / 4, canvas.width / canvas.height, 0.1, 100);

            const renderUniforms = new Float32Array(32);
            renderUniforms.set(view, 0);
            renderUniforms.set(projection, 16);
            device.queue.writeBuffer(renderUniformBuffer, 0, renderUniforms);

            const commandEncoder = device.createCommandEncoder();

            // Compute pass
            const computePass = commandEncoder.beginComputePass();
            computePass.setPipeline(computePipeline);
            computePass.setBindGroup(0, computeBindGroups[bufferIndex]);
            computePass.dispatchWorkgroups(Math.ceil(NUM_PARTICLES / 64));
            computePass.end();

            // Render pass
            const renderPass = commandEncoder.beginRenderPass({
                colorAttachments: [{
                    view: context.getCurrentTexture().createView(),
                    clearValue: { r: 0.05, g: 0.05, b: 0.1, a: 1 },
                    loadOp: 'clear',
                    storeOp: 'store',
                }],
                depthStencilAttachment: {
                    view: depthTexture.createView(),
                    depthClearValue: 1.0,
                    depthLoadOp: 'clear',
                    depthStoreOp: 'store',
                }
            });

            renderPass.setPipeline(renderPipeline);
            renderPass.setBindGroup(0, renderBindGroup);
            renderPass.setVertexBuffer(0, particleBuffers[(bufferIndex + 1) % 2]);
            renderPass.draw(NUM_PARTICLES);
            renderPass.end();

            device.queue.submit([commandEncoder.finish()]);

            bufferIndex = (bufferIndex + 1) % 2;
            requestAnimationFrame(render);
        }

        render();
    </script>
</body>
</html>
