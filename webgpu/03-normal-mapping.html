<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>03. Normal Mapping - WebGPU</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
            font-family: monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            border: 2px solid #16213e;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        .info {
            margin: 20px;
            padding: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            max-width: 800px;
        }
        h1 { color: #ffd700; }
        a { color: #4da6ff; }
    </style>
</head>
<body>
    <h1>03. Normal Mapping</h1>
    <canvas id="canvas" width="800" height="600"></canvas>
    <div class="info">
        <h3>Concept:</h3>
        <p>Normal mapping adds surface detail without adding geometry:</p>
        <ul>
            <li><strong>Normal Map:</strong> RGB texture storing surface normals in tangent space</li>
            <li><strong>Tangent Space:</strong> Local coordinate system per vertex (tangent, bitangent, normal)</li>
            <li><strong>Per-Pixel Lighting:</strong> Normals are perturbed per fragment for detailed lighting</li>
        </ul>
        <p>The plane shows a brick pattern created entirely from a procedural normal map - no actual geometry!</p>
        <a href="index.html">‚Üê Back to examples</a>
    </div>

    <script type="module">
        const canvas = document.getElementById('canvas');
        const adapter = await navigator.gpu?.requestAdapter();
        const device = await adapter?.requestDevice();

        if (!device) {
            alert('WebGPU not supported!');
            throw new Error('WebGPU not supported');
        }

        const context = canvas.getContext('webgpu');
        const format = navigator.gpu.getPreferredCanvasFormat();
        context.configure({ device, format });

        // Plane with tangent space data
        const planeVertices = new Float32Array([
            // pos(3), normal(3), uv(2), tangent(3)
            -3, 0, -3,  0, 1, 0,  0, 0,  1, 0, 0,
             3, 0, -3,  0, 1, 0,  3, 0,  1, 0, 0,
             3, 0,  3,  0, 1, 0,  3, 3,  1, 0, 0,
            -3, 0,  3,  0, 1, 0,  0, 3,  1, 0, 0,
        ]);

        const planeIndices = new Uint16Array([0, 1, 2, 0, 2, 3]);

        const vertexBuffer = device.createBuffer({
            size: planeVertices.byteLength,
            usage: GPUBufferUsage.VERTEX,
            mappedAtCreation: true,
        });
        new Float32Array(vertexBuffer.getMappedRange()).set(planeVertices);
        vertexBuffer.unmap();

        const indexBuffer = device.createBuffer({
            size: planeIndices.byteLength,
            usage: GPUBufferUsage.INDEX,
            mappedAtCreation: true,
        });
        new Uint16Array(indexBuffer.getMappedRange()).set(planeIndices);
        indexBuffer.unmap();

        // Create procedural normal map (brick pattern)
        function createBrickNormalMap() {
            const size = 256;
            const data = new Uint8Array(size * size * 4);

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const idx = (y * size + x) * 4;

                    // Brick pattern
                    const brickWidth = 64;
                    const brickHeight = 32;
                    const mortarSize = 4;

                    const brickX = x % brickWidth;
                    const brickY = y % brickHeight;
                    const rowOffset = (Math.floor(y / brickHeight) % 2) * (brickWidth / 2);
                    const adjustedX = (x + rowOffset) % brickWidth;

                    // Check if we're in mortar
                    const inMortar = brickX < mortarSize || brickY < mortarSize ||
                                     adjustedX < mortarSize;

                    if (inMortar) {
                        // Flat normal for mortar
                        data[idx] = 128;
                        data[idx + 1] = 128;
                        data[idx + 2] = 255;
                    } else {
                        // Perturbed normal for brick
                        const noise = (Math.sin(x * 0.1) * Math.cos(y * 0.1) * 0.5 + 0.5);
                        data[idx] = 128 + noise * 20;
                        data[idx + 1] = 128 + noise * 20;
                        data[idx + 2] = 200 + noise * 55;
                    }
                    data[idx + 3] = 255;
                }
            }

            return { data, width: size, height: size };
        }

        const normalMapData = createBrickNormalMap();
        const normalTexture = device.createTexture({
            size: [normalMapData.width, normalMapData.height],
            format: 'rgba8unorm',
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
        });

        device.queue.writeTexture(
            { texture: normalTexture },
            normalMapData.data,
            { bytesPerRow: normalMapData.width * 4 },
            [normalMapData.width, normalMapData.height]
        );

        const sampler = device.createSampler({
            magFilter: 'linear',
            minFilter: 'linear',
            mipmapFilter: 'linear',
            addressModeU: 'repeat',
            addressModeV: 'repeat',
        });

        // Uniforms
        const uniformBufferSize = 16 * 4 * 4 + 4 * 4 * 2;
        const uniformBuffer = device.createBuffer({
            size: uniformBufferSize,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        const bindGroupLayout = device.createBindGroupLayout({
            entries: [
                { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: 'uniform' } },
                { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: {} },
                { binding: 2, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
            ]
        });

        const bindGroup = device.createBindGroup({
            layout: bindGroupLayout,
            entries: [
                { binding: 0, resource: { buffer: uniformBuffer } },
                { binding: 1, resource: normalTexture.createView() },
                { binding: 2, resource: sampler },
            ]
        });

        const shaderCode = `
            struct Uniforms {
                model: mat4x4<f32>,
                view: mat4x4<f32>,
                projection: mat4x4<f32>,
                normalMatrix: mat4x4<f32>,
                lightPos: vec4<f32>,
                viewPos: vec4<f32>,
            }

            @group(0) @binding(0) var<uniform> uniforms: Uniforms;
            @group(0) @binding(1) var normalMap: texture_2d<f32>;
            @group(0) @binding(2) var texSampler: sampler;

            struct VertexInput {
                @location(0) position: vec3<f32>,
                @location(1) normal: vec3<f32>,
                @location(2) uv: vec2<f32>,
                @location(3) tangent: vec3<f32>,
            }

            struct VertexOutput {
                @builtin(position) position: vec4<f32>,
                @location(0) fragPosition: vec3<f32>,
                @location(1) uv: vec2<f32>,
                @location(2) TBN0: vec3<f32>,
                @location(3) TBN1: vec3<f32>,
                @location(4) TBN2: vec3<f32>,
            }

            @vertex
            fn vertexMain(input: VertexInput) -> VertexOutput {
                var output: VertexOutput;

                let worldPos = uniforms.model * vec4<f32>(input.position, 1.0);
                output.fragPosition = worldPos.xyz;
                output.position = uniforms.projection * uniforms.view * worldPos;
                output.uv = input.uv;

                // Create TBN matrix (tangent space to world space)
                let T = normalize((uniforms.normalMatrix * vec4<f32>(input.tangent, 0.0)).xyz);
                let N = normalize((uniforms.normalMatrix * vec4<f32>(input.normal, 0.0)).xyz);
                let B = cross(N, T);

                // Store TBN as columns
                output.TBN0 = vec3<f32>(T.x, B.x, N.x);
                output.TBN1 = vec3<f32>(T.y, B.y, N.y);
                output.TBN2 = vec3<f32>(T.z, B.z, N.z);

                return output;
            }

            @fragment
            fn fragmentMain(input: VertexOutput) -> @location(0) vec4<f32> {
                // Sample normal from normal map
                let normalSample = textureSample(normalMap, texSampler, input.uv).rgb;
                var tangentNormal = normalSample * 2.0 - 1.0;

                // Transform from tangent space to world space using TBN matrix
                let TBN = mat3x3<f32>(input.TBN0, input.TBN1, input.TBN2);
                let normal = normalize(TBN * tangentNormal);

                // Lighting calculations
                let lightDir = normalize(uniforms.lightPos.xyz - input.fragPosition);
                let viewDir = normalize(uniforms.viewPos.xyz - input.fragPosition);
                let halfDir = normalize(lightDir + viewDir);

                // Ambient
                let ambient = vec3<f32>(0.2, 0.15, 0.1);

                // Diffuse
                let diff = max(dot(normal, lightDir), 0.0);
                let diffuse = diff * vec3<f32>(0.7, 0.4, 0.3);

                // Specular
                let spec = pow(max(dot(normal, halfDir), 0.0), 32.0);
                let specular = spec * vec3<f32>(0.3, 0.3, 0.3);

                let result = ambient + diffuse + specular;
                return vec4<f32>(result, 1.0);
            }
        `;

        const shaderModule = device.createShaderModule({ code: shaderCode });

        const pipeline = device.createRenderPipeline({
            layout: device.createPipelineLayout({
                bindGroupLayouts: [bindGroupLayout]
            }),
            vertex: {
                module: shaderModule,
                entryPoint: 'vertexMain',
                buffers: [{
                    arrayStride: 11 * 4,
                    attributes: [
                        { shaderLocation: 0, offset: 0, format: 'float32x3' },
                        { shaderLocation: 1, offset: 3 * 4, format: 'float32x3' },
                        { shaderLocation: 2, offset: 6 * 4, format: 'float32x2' },
                        { shaderLocation: 3, offset: 8 * 4, format: 'float32x3' },
                    ]
                }]
            },
            fragment: {
                module: shaderModule,
                entryPoint: 'fragmentMain',
                targets: [{ format }]
            },
            primitive: {
                topology: 'triangle-list',
                cullMode: 'back',
            },
            depthStencil: {
                depthWriteEnabled: true,
                depthCompare: 'less',
                format: 'depth24plus',
            },
        });

        const depthTexture = device.createTexture({
            size: [canvas.width, canvas.height],
            format: 'depth24plus',
            usage: GPUTextureUsage.RENDER_ATTACHMENT,
        });

        // Matrix utilities
        function perspective(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) * nf, -1,
                0, 0, 2 * far * near * nf, 0
            ]);
        }

        function lookAt(eye, center, up) {
            const z = normalize([eye[0] - center[0], eye[1] - center[1], eye[2] - center[2]]);
            const x = normalize(cross(up, z));
            const y = cross(z, x);
            return new Float32Array([
                x[0], y[0], z[0], 0,
                x[1], y[1], z[1], 0,
                x[2], y[2], z[2], 0,
                -dot(x, eye), -dot(y, eye), -dot(z, eye), 1
            ]);
        }

        function identity() {
            return new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
        }

        function normalize(v) {
            const len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
            return [v[0]/len, v[1]/len, v[2]/len];
        }

        function cross(a, b) {
            return [
                a[1] * b[2] - a[2] * b[1],
                a[2] * b[0] - a[0] * b[2],
                a[0] * b[1] - a[1] * b[0]
            ];
        }

        function dot(a, b) {
            return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
        }

        let time = 0;
        function render() {
            time += 0.01;

            const lightPos = [Math.cos(time) * 5, 4, Math.sin(time) * 5];
            const viewPos = [0, 4, 6];

            const uniformData = new Float32Array(uniformBufferSize / 4);
            const model = identity();
            const view = lookAt(viewPos, [0, 0, 0], [0, 1, 0]);
            const projection = perspective(Math.PI / 4, canvas.width / canvas.height, 0.1, 100);

            uniformData.set(model, 0);
            uniformData.set(view, 16);
            uniformData.set(projection, 32);
            uniformData.set(identity(), 48); // normal matrix (identity for this case)
            uniformData.set(lightPos.concat([1]), 64);
            uniformData.set(viewPos.concat([1]), 68);

            device.queue.writeBuffer(uniformBuffer, 0, uniformData);

            const commandEncoder = device.createCommandEncoder();
            const renderPass = commandEncoder.beginRenderPass({
                colorAttachments: [{
                    view: context.getCurrentTexture().createView(),
                    clearValue: { r: 0.05, g: 0.05, b: 0.1, a: 1 },
                    loadOp: 'clear',
                    storeOp: 'store',
                }],
                depthStencilAttachment: {
                    view: depthTexture.createView(),
                    depthClearValue: 1.0,
                    depthLoadOp: 'clear',
                    depthStoreOp: 'store',
                }
            });

            renderPass.setPipeline(pipeline);
            renderPass.setBindGroup(0, bindGroup);
            renderPass.setVertexBuffer(0, vertexBuffer);
            renderPass.setIndexBuffer(indexBuffer, 'uint16');
            renderPass.drawIndexed(planeIndices.length);
            renderPass.end();

            device.queue.submit([commandEncoder.finish()]);
            requestAnimationFrame(render);
        }

        render();
    </script>
</body>
</html>
