<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>04. Skybox - WebGPU</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
            font-family: monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            border: 2px solid #16213e;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        .info {
            margin: 20px;
            padding: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            max-width: 800px;
        }
        h1 { color: #ffd700; }
        a { color: #4da6ff; }
    </style>
</head>
<body>
    <h1>04. Skybox</h1>
    <canvas id="canvas" width="800" height="600"></canvas>
    <div class="info">
        <h3>Concept:</h3>
        <p>Skybox creates an immersive environment using cube mapping:</p>
        <ul>
            <li><strong>Cube Texture:</strong> 6 faces (±X, ±Y, ±Z) forming a cube around the scene</li>
            <li><strong>View Direction Sampling:</strong> Uses camera direction as texture coordinates</li>
            <li><strong>Depth Trick:</strong> Rendered with z=1.0 to always be behind everything</li>
        </ul>
        <p>Use mouse to look around! The skybox shows a procedural day/night gradient with stars.</p>
        <a href="index.html">← Back to examples</a>
    </div>

    <script type="module">
        const canvas = document.getElementById('canvas');
        const adapter = await navigator.gpu?.requestAdapter();
        const device = await adapter?.requestDevice();

        if (!device) {
            alert('WebGPU not supported!');
            throw new Error('WebGPU not supported');
        }

        const context = canvas.getContext('webgpu');
        const format = navigator.gpu.getPreferredCanvasFormat();
        context.configure({ device, format });

        // Skybox cube vertices (just positions, we'll sample using view direction)
        const skyboxVertices = new Float32Array([
            // positions (center at origin, will be transformed to world space)
            -1, -1, -1,   1, -1, -1,   1,  1, -1,  -1,  1, -1, // back
            -1, -1,  1,  -1,  1,  1,   1,  1,  1,   1, -1,  1, // front
            -1,  1, -1,  -1,  1,  1,   1,  1,  1,   1,  1, -1, // top
            -1, -1, -1,   1, -1, -1,   1, -1,  1,  -1, -1,  1, // bottom
             1, -1, -1,   1, -1,  1,   1,  1,  1,   1,  1, -1, // right
            -1, -1, -1,  -1,  1, -1,  -1,  1,  1,  -1, -1,  1, // left
        ]);

        const skyboxIndices = new Uint16Array([
            0,  1,  2,    0,  2,  3,
            4,  5,  6,    4,  6,  7,
            8,  9, 10,    8, 10, 11,
           12, 13, 14,   12, 14, 15,
           16, 17, 18,   16, 18, 19,
           20, 21, 22,   20, 22, 23,
        ]);

        const vertexBuffer = device.createBuffer({
            size: skyboxVertices.byteLength,
            usage: GPUBufferUsage.VERTEX,
            mappedAtCreation: true,
        });
        new Float32Array(vertexBuffer.getMappedRange()).set(skyboxVertices);
        vertexBuffer.unmap();

        const indexBuffer = device.createBuffer({
            size: skyboxIndices.byteLength,
            usage: GPUBufferUsage.INDEX,
            mappedAtCreation: true,
        });
        new Uint16Array(indexBuffer.getMappedRange()).set(skyboxIndices);
        indexBuffer.unmap();

        // Create procedural skybox cubemap
        function createSkyboxTexture() {
            const faceSize = 512;
            const faces = 6;

            // Generate gradient sky with stars
            function generateFace(faceIndex) {
                const data = new Uint8Array(faceSize * faceSize * 4);

                for (let y = 0; y < faceSize; y++) {
                    for (let x = 0; x < faceSize; x++) {
                        const idx = (y * faceSize + x) * 4;

                        // Get 3D direction for this pixel on this face
                        let dx, dy, dz;
                        const u = (x / faceSize) * 2 - 1;
                        const v = (y / faceSize) * 2 - 1;

                        switch(faceIndex) {
                            case 0: dx =  1; dy = -v; dz = -u; break; // +X
                            case 1: dx = -1; dy = -v; dz =  u; break; // -X
                            case 2: dx =  u; dy =  1; dz =  v; break; // +Y
                            case 3: dx =  u; dy = -1; dz = -v; break; // -Y
                            case 4: dx =  u; dy = -v; dz =  1; break; // +Z
                            case 5: dx = -u; dy = -v; dz = -1; break; // -Z
                        }

                        const len = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        dx /= len; dy /= len; dz /= len;

                        // Gradient based on Y (up/down)
                        const t = dy * 0.5 + 0.5; // 0 = bottom, 1 = top

                        // Sky color gradient
                        const horizonColor = [255, 200, 150];
                        const zenithColor = [20, 60, 120];
                        const nadirColor = [10, 10, 30];

                        let r, g, b;
                        if (dy > 0) {
                            r = horizonColor[0] * (1-dy) + zenithColor[0] * dy;
                            g = horizonColor[1] * (1-dy) + zenithColor[1] * dy;
                            b = horizonColor[2] * (1-dy) + zenithColor[2] * dy;
                        } else {
                            const t = -dy;
                            r = horizonColor[0] * (1-t) + nadirColor[0] * t;
                            g = horizonColor[1] * (1-t) + nadirColor[1] * t;
                            b = horizonColor[2] * (1-t) + nadirColor[2] * t;
                        }

                        // Add some stars
                        const starNoise = Math.sin(dx * 500) * Math.sin(dy * 500) * Math.sin(dz * 500);
                        if (starNoise > 0.998 && dy > 0.3) {
                            r = g = b = 255;
                        }

                        data[idx] = r;
                        data[idx + 1] = g;
                        data[idx + 2] = b;
                        data[idx + 3] = 255;
                    }
                }

                return data;
            }

            const texture = device.createTexture({
                size: [faceSize, faceSize, 6],
                format: 'rgba8unorm',
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
                dimension: '2d',
            });

            for (let face = 0; face < 6; face++) {
                const faceData = generateFace(face);
                device.queue.writeTexture(
                    { texture, origin: [0, 0, face] },
                    faceData,
                    { bytesPerRow: faceSize * 4 },
                    [faceSize, faceSize, 1]
                );
            }

            return texture;
        }

        const skyboxTexture = createSkyboxTexture();
        const skyboxSampler = device.createSampler({
            magFilter: 'linear',
            minFilter: 'linear',
        });

        // Uniforms
        const uniformBufferSize = 16 * 4 * 2; // view and projection matrices
        const uniformBuffer = device.createBuffer({
            size: uniformBufferSize,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        const bindGroupLayout = device.createBindGroupLayout({
            entries: [
                { binding: 0, visibility: GPUShaderStage.VERTEX, buffer: { type: 'uniform' } },
                { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { viewDimension: 'cube' } },
                { binding: 2, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
            ]
        });

        const bindGroup = device.createBindGroup({
            layout: bindGroupLayout,
            entries: [
                { binding: 0, resource: { buffer: uniformBuffer } },
                { binding: 1, resource: skyboxTexture.createView({ dimension: 'cube' }) },
                { binding: 2, resource: skyboxSampler },
            ]
        });

        const shaderCode = `
            struct Uniforms {
                viewProj: mat4x4<f32>,
                invViewProj: mat4x4<f32>,
            }

            @group(0) @binding(0) var<uniform> uniforms: Uniforms;
            @group(0) @binding(1) var skybox: texture_cube<f32>;
            @group(0) @binding(2) var skyboxSampler: sampler;

            struct VertexOutput {
                @builtin(position) position: vec4<f32>,
                @location(0) texCoord: vec3<f32>,
            }

            @vertex
            fn vertexMain(@location(0) position: vec3<f32>) -> VertexOutput {
                var output: VertexOutput;
                // Remove translation from view matrix, keep rotation only
                var pos = uniforms.viewProj * vec4<f32>(position, 0.0);
                // Set z to w so after perspective divide, z = 1.0 (far plane)
                output.position = vec4<f32>(pos.xy, pos.w, pos.w);
                output.texCoord = position;
                return output;
            }

            @fragment
            fn fragmentMain(input: VertexOutput) -> @location(0) vec4<f32> {
                return textureSample(skybox, skyboxSampler, input.texCoord);
            }
        `;

        const shaderModule = device.createShaderModule({ code: shaderCode });

        const pipeline = device.createRenderPipeline({
            layout: device.createPipelineLayout({
                bindGroupLayouts: [bindGroupLayout]
            }),
            vertex: {
                module: shaderModule,
                entryPoint: 'vertexMain',
                buffers: [{
                    arrayStride: 3 * 4,
                    attributes: [
                        { shaderLocation: 0, offset: 0, format: 'float32x3' },
                    ]
                }]
            },
            fragment: {
                module: shaderModule,
                entryPoint: 'fragmentMain',
                targets: [{ format }]
            },
            primitive: {
                topology: 'triangle-list',
                cullMode: 'front', // Cull front faces since we're inside the cube
            },
            depthStencil: {
                depthWriteEnabled: false,
                depthCompare: 'less-equal',
                format: 'depth24plus',
            },
        });

        const depthTexture = device.createTexture({
            size: [canvas.width, canvas.height],
            format: 'depth24plus',
            usage: GPUTextureUsage.RENDER_ATTACHMENT,
        });

        // Matrix utilities
        function perspective(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) * nf, -1,
                0, 0, 2 * far * near * nf, 0
            ]);
        }

        function lookAt(eye, center, up) {
            const z = normalize([eye[0] - center[0], eye[1] - center[1], eye[2] - center[2]]);
            const x = normalize(cross(up, z));
            const y = cross(z, x);
            return new Float32Array([
                x[0], y[0], z[0], 0,
                x[1], y[1], z[1], 0,
                x[2], y[2], z[2], 0,
                -dot(x, eye), -dot(y, eye), -dot(z, eye), 1
            ]);
        }

        function multiply(a, b) {
            const result = new Float32Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    result[i * 4 + j] =
                        a[i * 4 + 0] * b[0 * 4 + j] +
                        a[i * 4 + 1] * b[1 * 4 + j] +
                        a[i * 4 + 2] * b[2 * 4 + j] +
                        a[i * 4 + 3] * b[3 * 4 + j];
                }
            }
            return result;
        }

        function normalize(v) {
            const len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
            return [v[0]/len, v[1]/len, v[2]/len];
        }

        function cross(a, b) {
            return [
                a[1] * b[2] - a[2] * b[1],
                a[2] * b[0] - a[0] * b[2],
                a[0] * b[1] - a[1] * b[0]
            ];
        }

        function dot(a, b) {
            return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
        }

        // Mouse look controls
        let yaw = 0, pitch = 0;
        let isDragging = false;
        let lastX = 0, lastY = 0;

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - lastX;
                const deltaY = e.clientY - lastY;
                yaw += deltaX * 0.005;
                pitch -= deltaY * 0.005;
                pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, pitch));
                lastX = e.clientX;
                lastY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', () => isDragging = false);
        canvas.addEventListener('mouseleave', () => isDragging = false);

        function render() {
            // Calculate camera position based on yaw and pitch
            const camX = Math.cos(pitch) * Math.sin(yaw);
            const camY = Math.sin(pitch);
            const camZ = Math.cos(pitch) * Math.cos(yaw);

            const view = lookAt([0, 0, 0], [camX, camY, camZ], [0, 1, 0]);
            const projection = perspective(Math.PI / 3, canvas.width / canvas.height, 0.1, 100);

            // Remove translation from view matrix
            const viewNoTranslation = new Float32Array(view);
            viewNoTranslation[12] = 0;
            viewNoTranslation[13] = 0;
            viewNoTranslation[14] = 0;

            const viewProj = multiply(projection, viewNoTranslation);

            const uniformData = new Float32Array(uniformBufferSize / 4);
            uniformData.set(viewProj, 0);
            uniformData.set(viewProj, 16); // invViewProj not used in this simple version

            device.queue.writeBuffer(uniformBuffer, 0, uniformData);

            const commandEncoder = device.createCommandEncoder();
            const renderPass = commandEncoder.beginRenderPass({
                colorAttachments: [{
                    view: context.getCurrentTexture().createView(),
                    clearValue: { r: 0, g: 0, b: 0, a: 1 },
                    loadOp: 'clear',
                    storeOp: 'store',
                }],
                depthStencilAttachment: {
                    view: depthTexture.createView(),
                    depthClearValue: 1.0,
                    depthLoadOp: 'clear',
                    depthStoreOp: 'store',
                }
            });

            renderPass.setPipeline(pipeline);
            renderPass.setBindGroup(0, bindGroup);
            renderPass.setVertexBuffer(0, vertexBuffer);
            renderPass.setIndexBuffer(indexBuffer, 'uint16');
            renderPass.drawIndexed(skyboxIndices.length);
            renderPass.end();

            device.queue.submit([commandEncoder.finish()]);
            requestAnimationFrame(render);
        }

        render();
    </script>
</body>
</html>
