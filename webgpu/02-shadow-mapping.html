<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>02. Shadow Mapping - WebGPU</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
            font-family: monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            border: 2px solid #16213e;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        .info {
            margin: 20px;
            padding: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            max-width: 800px;
        }
        h1 { color: #ffd700; }
        a { color: #4da6ff; }
    </style>
</head>
<body>
    <h1>02. Shadow Mapping</h1>
    <canvas id="canvas" width="800" height="600"></canvas>
    <div class="info">
        <h3>Concept:</h3>
        <p>Shadow mapping is a two-pass technique:</p>
        <ul>
            <li><strong>Pass 1 (Shadow Pass):</strong> Render scene from light's perspective into a depth texture</li>
            <li><strong>Pass 2 (Main Pass):</strong> Render scene normally, comparing fragment depth to shadow map</li>
        </ul>
        <p>The rotating cube casts realistic shadows on the ground plane. Notice how shadows dynamically update.</p>
        <a href="index.html">‚Üê Back to examples</a>
    </div>

    <script type="module">
        const canvas = document.getElementById('canvas');
        const adapter = await navigator.gpu?.requestAdapter();
        const device = await adapter?.requestDevice();

        if (!device) {
            alert('WebGPU not supported!');
            throw new Error('WebGPU not supported');
        }

        const context = canvas.getContext('webgpu');
        const format = navigator.gpu.getPreferredCanvasFormat();
        context.configure({ device, format });

        // Cube vertices
        const cubeVertices = new Float32Array([
            // Front
            -1, -1,  1,  0,  0,  1,
             1, -1,  1,  0,  0,  1,
             1,  1,  1,  0,  0,  1,
            -1,  1,  1,  0,  0,  1,
            // Back
            -1, -1, -1,  0,  0, -1,
            -1,  1, -1,  0,  0, -1,
             1,  1, -1,  0,  0, -1,
             1, -1, -1,  0,  0, -1,
            // Top
            -1,  1, -1,  0,  1,  0,
            -1,  1,  1,  0,  1,  0,
             1,  1,  1,  0,  1,  0,
             1,  1, -1,  0,  1,  0,
            // Bottom
            -1, -1, -1,  0, -1,  0,
             1, -1, -1,  0, -1,  0,
             1, -1,  1,  0, -1,  0,
            -1, -1,  1,  0, -1,  0,
            // Right
             1, -1, -1,  1,  0,  0,
             1,  1, -1,  1,  0,  0,
             1,  1,  1,  1,  0,  0,
             1, -1,  1,  1,  0,  0,
            // Left
            -1, -1, -1, -1,  0,  0,
            -1, -1,  1, -1,  0,  0,
            -1,  1,  1, -1,  0,  0,
            -1,  1, -1, -1,  0,  0,
        ]);

        const cubeIndices = new Uint16Array([
            0,  1,  2,    0,  2,  3,
            4,  5,  6,    4,  6,  7,
            8,  9, 10,    8, 10, 11,
           12, 13, 14,   12, 14, 15,
           16, 17, 18,   16, 18, 19,
           20, 21, 22,   20, 22, 23,
        ]);

        // Ground plane
        const planeVertices = new Float32Array([
            -5, -2, -5,  0,  1,  0,
             5, -2, -5,  0,  1,  0,
             5, -2,  5,  0,  1,  0,
            -5, -2,  5,  0,  1,  0,
        ]);

        const planeIndices = new Uint16Array([0, 1, 2, 0, 2, 3]);

        function createBuffers(vertices, indices) {
            const vertexBuffer = device.createBuffer({
                size: vertices.byteLength,
                usage: GPUBufferUsage.VERTEX,
                mappedAtCreation: true,
            });
            new Float32Array(vertexBuffer.getMappedRange()).set(vertices);
            vertexBuffer.unmap();

            const indexBuffer = device.createBuffer({
                size: indices.byteLength,
                usage: GPUBufferUsage.INDEX,
                mappedAtCreation: true,
            });
            new Uint16Array(indexBuffer.getMappedRange()).set(indices);
            indexBuffer.unmap();

            return { vertexBuffer, indexBuffer };
        }

        const cube = createBuffers(cubeVertices, cubeIndices);
        const plane = createBuffers(planeVertices, planeIndices);

        // Shadow map
        const shadowMapSize = 2048;
        const shadowDepthTexture = device.createTexture({
            size: [shadowMapSize, shadowMapSize],
            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,
            format: 'depth32float',
        });

        const shadowDepthTextureView = shadowDepthTexture.createView();

        // Sampler for shadow map
        const shadowSampler = device.createSampler({
            compare: 'less',
        });

        // Uniforms
        const uniformBufferSize = 16 * 4 * 6; // 6 matrices
        const uniformBuffer = device.createBuffer({
            size: uniformBufferSize,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        // Shadow pass shader (simple depth write)
        const shadowShader = `
            struct Uniforms {
                lightSpaceMatrix: mat4x4<f32>,
            }

            @group(0) @binding(0) var<uniform> uniforms: Uniforms;

            struct VertexInput {
                @location(0) position: vec3<f32>,
                @location(1) normal: vec3<f32>,
            }

            @vertex
            fn vertexMain(input: VertexInput) -> @builtin(position) vec4<f32> {
                return uniforms.lightSpaceMatrix * vec4<f32>(input.position, 1.0);
            }
        `;

        // Main render shader
        const mainShader = `
            struct Uniforms {
                model: mat4x4<f32>,
                view: mat4x4<f32>,
                projection: mat4x4<f32>,
                lightSpaceMatrix: mat4x4<f32>,
                lightPos: vec4<f32>,
                viewPos: vec4<f32>,
            }

            @group(0) @binding(0) var<uniform> uniforms: Uniforms;
            @group(0) @binding(1) var shadowMap: texture_depth_2d;
            @group(0) @binding(2) var shadowSampler: sampler_comparison;

            struct VertexInput {
                @location(0) position: vec3<f32>,
                @location(1) normal: vec3<f32>,
            }

            struct VertexOutput {
                @builtin(position) position: vec4<f32>,
                @location(0) fragPosition: vec3<f32>,
                @location(1) normal: vec3<f32>,
                @location(2) lightSpacePos: vec4<f32>,
            }

            @vertex
            fn vertexMain(input: VertexInput) -> VertexOutput {
                var output: VertexOutput;
                let worldPos = uniforms.model * vec4<f32>(input.position, 1.0);
                output.fragPosition = worldPos.xyz;
                output.position = uniforms.projection * uniforms.view * worldPos;
                output.normal = (uniforms.model * vec4<f32>(input.normal, 0.0)).xyz;
                output.lightSpacePos = uniforms.lightSpaceMatrix * worldPos;
                return output;
            }

            @fragment
            fn fragmentMain(input: VertexOutput) -> @location(0) vec4<f32> {
                let normal = normalize(input.normal);
                let lightDir = normalize(uniforms.lightPos.xyz - input.fragPosition);

                // Project to light space
                var lightSpacePos = input.lightSpacePos.xyz / input.lightSpacePos.w;
                lightSpacePos = lightSpacePos * 0.5 + 0.5;
                lightSpacePos.y = 1.0 - lightSpacePos.y;

                // Sample shadow map with PCF
                var shadow = 0.0;
                let texelSize = 1.0 / 2048.0;
                for (var x = -1; x <= 1; x++) {
                    for (var y = -1; y <= 1; y++) {
                        let offset = vec2<f32>(f32(x), f32(y)) * texelSize;
                        let coords = lightSpacePos.xy + offset;
                        shadow += textureSampleCompare(shadowMap, shadowSampler, coords, lightSpacePos.z - 0.005);
                    }
                }
                shadow /= 9.0;

                // Lighting
                let ambient = vec3<f32>(0.2, 0.3, 0.4) * 0.3;
                let diff = max(dot(normal, lightDir), 0.0);
                let diffuse = diff * vec3<f32>(0.4, 0.6, 0.8);

                let result = ambient + shadow * diffuse;
                return vec4<f32>(result, 1.0);
            }
        `;

        const shadowModule = device.createShaderModule({ code: shadowShader });
        const mainModule = device.createShaderModule({ code: mainShader });

        const vertexBufferLayout = {
            arrayStride: 6 * 4,
            attributes: [
                { shaderLocation: 0, offset: 0, format: 'float32x3' },
                { shaderLocation: 1, offset: 3 * 4, format: 'float32x3' },
            ]
        };

        // Shadow pipeline
        const shadowBindGroupLayout = device.createBindGroupLayout({
            entries: [{
                binding: 0,
                visibility: GPUShaderStage.VERTEX,
                buffer: { type: 'uniform' }
            }]
        });

        const shadowPipeline = device.createRenderPipeline({
            layout: device.createPipelineLayout({
                bindGroupLayouts: [shadowBindGroupLayout]
            }),
            vertex: {
                module: shadowModule,
                entryPoint: 'vertexMain',
                buffers: [vertexBufferLayout]
            },
            primitive: {
                topology: 'triangle-list',
                cullMode: 'back',
            },
            depthStencil: {
                depthWriteEnabled: true,
                depthCompare: 'less',
                format: 'depth32float',
            },
        });

        // Main pipeline
        const mainBindGroupLayout = device.createBindGroupLayout({
            entries: [
                { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: 'uniform' } },
                { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'depth' } },
                { binding: 2, visibility: GPUShaderStage.FRAGMENT, sampler: { type: 'comparison' } },
            ]
        });

        const mainPipeline = device.createRenderPipeline({
            layout: device.createPipelineLayout({
                bindGroupLayouts: [mainBindGroupLayout]
            }),
            vertex: {
                module: mainModule,
                entryPoint: 'vertexMain',
                buffers: [vertexBufferLayout]
            },
            fragment: {
                module: mainModule,
                entryPoint: 'fragmentMain',
                targets: [{ format }]
            },
            primitive: {
                topology: 'triangle-list',
                cullMode: 'back',
            },
            depthStencil: {
                depthWriteEnabled: true,
                depthCompare: 'less',
                format: 'depth24plus',
            },
        });

        const shadowBindGroup = device.createBindGroup({
            layout: shadowBindGroupLayout,
            entries: [{ binding: 0, resource: { buffer: uniformBuffer } }]
        });

        const mainBindGroup = device.createBindGroup({
            layout: mainBindGroupLayout,
            entries: [
                { binding: 0, resource: { buffer: uniformBuffer } },
                { binding: 1, resource: shadowDepthTextureView },
                { binding: 2, resource: shadowSampler },
            ]
        });

        const depthTexture = device.createTexture({
            size: [canvas.width, canvas.height],
            format: 'depth24plus',
            usage: GPUTextureUsage.RENDER_ATTACHMENT,
        });

        // Matrix utilities
        function perspective(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) * nf, -1,
                0, 0, 2 * far * near * nf, 0
            ]);
        }

        function ortho(left, right, bottom, top, near, far) {
            return new Float32Array([
                2 / (right - left), 0, 0, 0,
                0, 2 / (top - bottom), 0, 0,
                0, 0, -2 / (far - near), 0,
                -(right + left) / (right - left),
                -(top + bottom) / (top - bottom),
                -(far + near) / (far - near), 1
            ]);
        }

        function lookAt(eye, center, up) {
            const z = normalize([eye[0] - center[0], eye[1] - center[1], eye[2] - center[2]]);
            const x = normalize(cross(up, z));
            const y = cross(z, x);
            return new Float32Array([
                x[0], y[0], z[0], 0,
                x[1], y[1], z[1], 0,
                x[2], y[2], z[2], 0,
                -dot(x, eye), -dot(y, eye), -dot(z, eye), 1
            ]);
        }

        function rotateY(angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            return new Float32Array([
                c, 0, s, 0,
                0, 1, 0, 0,
                -s, 0, c, 0,
                0, 0, 0, 1
            ]);
        }

        function identity() {
            return new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
        }

        function multiply(a, b) {
            const result = new Float32Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    result[i * 4 + j] =
                        a[i * 4 + 0] * b[0 * 4 + j] +
                        a[i * 4 + 1] * b[1 * 4 + j] +
                        a[i * 4 + 2] * b[2 * 4 + j] +
                        a[i * 4 + 3] * b[3 * 4 + j];
                }
            }
            return result;
        }

        function normalize(v) {
            const len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
            return [v[0]/len, v[1]/len, v[2]/len];
        }

        function cross(a, b) {
            return [
                a[1] * b[2] - a[2] * b[1],
                a[2] * b[0] - a[0] * b[2],
                a[0] * b[1] - a[1] * b[0]
            ];
        }

        function dot(a, b) {
            return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
        }

        let rotation = 0;
        function render() {
            rotation += 0.01;

            const lightPos = [5, 5, 5];
            const lightView = lookAt(lightPos, [0, 0, 0], [0, 1, 0]);
            const lightProjection = ortho(-10, 10, -10, 10, 1, 20);
            const lightSpaceMatrix = multiply(lightProjection, lightView);

            const cubeModel = rotateY(rotation);
            const planeModel = identity();
            const view = lookAt([0, 3, 8], [0, 0, 0], [0, 1, 0]);
            const projection = perspective(Math.PI / 4, canvas.width / canvas.height, 0.1, 100);

            const commandEncoder = device.createCommandEncoder();

            // Shadow pass
            const shadowPass = commandEncoder.beginRenderPass({
                colorAttachments: [],
                depthStencilAttachment: {
                    view: shadowDepthTextureView,
                    depthClearValue: 1.0,
                    depthLoadOp: 'clear',
                    depthStoreOp: 'store',
                }
            });

            shadowPass.setPipeline(shadowPipeline);
            shadowPass.setBindGroup(0, shadowBindGroup);

            // Render cube to shadow map
            device.queue.writeBuffer(uniformBuffer, 0, multiply(lightSpaceMatrix, cubeModel));
            shadowPass.setVertexBuffer(0, cube.vertexBuffer);
            shadowPass.setIndexBuffer(cube.indexBuffer, 'uint16');
            shadowPass.drawIndexed(cubeIndices.length);

            // Render plane to shadow map
            device.queue.writeBuffer(uniformBuffer, 0, multiply(lightSpaceMatrix, planeModel));
            shadowPass.setVertexBuffer(0, plane.vertexBuffer);
            shadowPass.setIndexBuffer(plane.indexBuffer, 'uint16');
            shadowPass.drawIndexed(planeIndices.length);

            shadowPass.end();

            // Main pass
            const mainPass = commandEncoder.beginRenderPass({
                colorAttachments: [{
                    view: context.getCurrentTexture().createView(),
                    clearValue: { r: 0.1, g: 0.1, b: 0.15, a: 1 },
                    loadOp: 'clear',
                    storeOp: 'store',
                }],
                depthStencilAttachment: {
                    view: depthTexture.createView(),
                    depthClearValue: 1.0,
                    depthLoadOp: 'clear',
                    depthStoreOp: 'store',
                }
            });

            mainPass.setPipeline(mainPipeline);
            mainPass.setBindGroup(0, mainBindGroup);

            // Render cube
            const cubeUniforms = new Float32Array(uniformBufferSize / 4);
            cubeUniforms.set(cubeModel, 0);
            cubeUniforms.set(view, 16);
            cubeUniforms.set(projection, 32);
            cubeUniforms.set(lightSpaceMatrix, 48);
            cubeUniforms.set(lightPos.concat([1]), 64);
            cubeUniforms.set([0, 3, 8, 1], 68);
            device.queue.writeBuffer(uniformBuffer, 0, cubeUniforms);

            mainPass.setVertexBuffer(0, cube.vertexBuffer);
            mainPass.setIndexBuffer(cube.indexBuffer, 'uint16');
            mainPass.drawIndexed(cubeIndices.length);

            // Render plane
            const planeUniforms = new Float32Array(uniformBufferSize / 4);
            planeUniforms.set(planeModel, 0);
            planeUniforms.set(view, 16);
            planeUniforms.set(projection, 32);
            planeUniforms.set(lightSpaceMatrix, 48);
            planeUniforms.set(lightPos.concat([1]), 64);
            planeUniforms.set([0, 3, 8, 1], 68);
            device.queue.writeBuffer(uniformBuffer, 0, planeUniforms);

            mainPass.setVertexBuffer(0, plane.vertexBuffer);
            mainPass.setIndexBuffer(plane.indexBuffer, 'uint16');
            mainPass.drawIndexed(planeIndices.length);

            mainPass.end();

            device.queue.submit([commandEncoder.finish()]);
            requestAnimationFrame(render);
        }

        render();
    </script>
</body>
</html>
